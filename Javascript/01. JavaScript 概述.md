# Javascript 概述

JS(JavaScript, 下同) 是面向对象的语言。

</br>

### 语法特点

**JS 严格区分大小写**，每一条语句以分号结尾。  
 \- 如果不写分号，浏览器会自动添加，但会消耗一些系统资源。有时浏览器会加错分号。

**JS 中会忽略多个空格和换行**，JS 还将制表符、各种 ASCII 控制字符和各种 Unicode 空格字符识别为空格。

JavaScript 支持两种注释。如下：
```JavaScript
// I am a comment.

/* No, I am the comment! */

/* I am comment,
in
different lines. */
```

</br>

### 进制

在 JS 中，如果表示16进制的数字，需要以 0x 开头；如果表示 8 进制的数字，需要以 0 开头；如果表示 2 进制数字，需要以 0b 开头，但并非所有浏览器都支持二进制。

不同进制的数值的输出值都为十进制。

</br>

### 垃圾回收 Garbage Collection

正如人生活的时间长了以后会产生垃圾一样，程序运行的过程中也会产生垃圾，积攒过多以后会导致程序的运行速度过慢。（垃圾语言，毁灭吧）

当一个对象没有任何变量或属性对它进行应用，无法操作此对象，这种对象就是一个垃圾，会占用大量的内存空间，导致程序便秘。

JS 拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁。我们无需也不能进行垃圾回收操作。不同浏览器的回收方法不同。

对于不再使用的对象，将其赋值为 null，会触发 GC 机制将其销毁。

</br>

### 严格模式 use strict

ECMAScript 5 的严格模式是采用具有限制性 JavaScript 变体的一种方式，从而使代码隐式地脱离“马虎模式”（sloppy mode，非官方术语）。严格模式不仅仅是一个子集：它的产生是为了形成与正常代码不同的语义。

通常来说不应该在代码中混合使用 strict mode 和 non-strict mode，整个程序要么严格要么非严格。然而有时候可能会用到第三方库，模式可能跟其他代码有所不同，要注意兼容性细节。

 \- 通过抛出错误来消除了一些原有静默错误（将过失错误转成异常）。  
 \- 修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。  
 \- 禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。  

在严格模式下，禁止自动或隐式创建全局变量，引擎会抛出异常：ReferenceError。

在严格模式下，eval() 函数在运行时有自己的作用域，在其中的声明无法修改所在的作用域。

```javascript
function f(str) {
    "use strict";
    eval(str);
    console.log(a);			// ReferenceError: a is not defind
}
f("var a = 2")
```

在程序中动态生成代码的情景很少见。（欺骗词法作用域会导致性能下降）

</br>

### 作用域 Scope

指一个变量的存储范围。作用域有两种主要的工作模型：词法作用域和动态作用域。Javascript 采用的是前者。

​	&nbsp;&nbsp;**全局作用域**

直接编写在 script 标签中的 JS 代码，都在全局作用域。在页面打开时创建，在页面关闭时销毁。

全局作用域中有全局对象 window。它代表浏览器窗口，又浏览器创建，可以直接使用。在全局作用域中创建的变量都会作为 window 对象的属性保存，可以通过全局对象来对其进行访问（用来访问被同名变量遮蔽的全局变量）。

```javascript
var a = 10;
console.log(window.a);	//输出 a
```


同理，在全局中的函数将会作为该对象的方法。

尽量不要在全局作用域中声明变量或是定义函数，会污染全局作用域的命名空间。而且定义在全局作用域也不安全。

​	&nbsp;&nbsp;**函数作用域**

也称局部作用域。调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁。每创建一次函数会创建一个新的函数作用域，它们之间相互独立。

函数作用域中可以访问到全局作用域的的变量，在全局作用域中无法访问函数作用域中的变量。

当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用。如果没有则向上一级作用域中查找，直到找到全局作用域。如果仍未找到，则会抛出异常：ReferenceError。

在函数作用域中如果想访问全局作用域中的变量，可以调用 window 对象。

在函数作用域中，不使用 var 声明的变量都会设置为全局变量。
